"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRegisterResourceTemplate = exports.createRegisterResource = exports.formatResult = void 0;
const shared_js_1 = require("./shared.js");
async function formatResult(value, uri, init) {
    if (typeof value === "undefined") {
        return { contents: [] };
    }
    let contents = [];
    const mimeType = init.mimeType ?? init.response?.headers.get("content-type")
        ?? "";
    if (mimeType.search(/\bjson\b/g) !== -1) {
        contents = [{ uri: uri.toString(), mimeType, text: JSON.stringify(value) }];
    }
    else if (mimeType.startsWith("text/event-stream")
        && (0, shared_js_1.isAsyncIterable)(value)) {
        contents = [
            {
                uri: uri.toString(),
                mimeType: "application/json",
                text: await stringifySSEToJSON(value),
            },
        ];
    }
    else if ((mimeType.startsWith("text/") || mimeType.startsWith("application/"))
        && typeof value === "string") {
        contents = [{ uri: uri.toString(), mimeType, text: value }];
    }
    else if ((0, shared_js_1.isBinaryData)(value)) {
        const blob = await (0, shared_js_1.valueToBase64)(value);
        contents = blob == null ? [] : [{ uri: uri.toString(), blob, mimeType }];
    }
    else {
        throw new Error(`Unsupported content type: "${mimeType}"`);
    }
    return { contents };
}
exports.formatResult = formatResult;
async function stringifySSEToJSON(value) {
    const payloads = [];
    for await (const chunk of value) {
        payloads.push(chunk);
    }
    return JSON.stringify(payloads);
}
function createRegisterResource(logger, server, sdk, allowedScopes) {
    return (resource) => {
        const scopes = resource.scopes ?? [];
        if (!scopes.every((s) => allowedScopes.has(s))) {
            return;
        }
        const metadata = {
            ...resource.metadata,
            description: resource.description,
        };
        server.resource(resource.name, resource.resource, metadata, async (uri, ctx) => resource.read(sdk, uri, ctx));
        logger.debug("Registered resource", { name: resource.name });
    };
}
exports.createRegisterResource = createRegisterResource;
function createRegisterResourceTemplate(logger, server, sdk, allowedScopes) {
    return (resource) => {
        const scopes = resource.scopes ?? [];
        if (!scopes.every((s) => allowedScopes.has(s))) {
            return;
        }
        const metadata = {
            ...resource.metadata,
            description: resource.description,
        };
        server.resource(resource.name, resource.resource, metadata, async (uri, vars, ctx) => resource.read(sdk, uri, vars, ctx));
        logger.debug("Registered resource template", { name: resource.name });
    };
}
exports.createRegisterResourceTemplate = createRegisterResourceTemplate;
//# sourceMappingURL=resources.js.map