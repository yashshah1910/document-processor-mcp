/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
import { SDKError } from "../sdk/models/errors/sdkerror.js";
import { matchResponse, matchStatusCode } from "./http.js";
import { isPlainObject } from "./is-plain-object.js";
import { safeParse } from "./schemas.js";
const DEFAULT_CONTENT_TYPES = {
    json: "application/json",
    text: "text/plain",
    bytes: "application/octet-stream",
    stream: "application/octet-stream",
    sse: "text/event-stream",
    nil: "*",
    fail: "*",
};
export function jsonErr(codes, schema, options) {
    return { ...options, err: true, enc: "json", codes, schema };
}
export function json(codes, schema, options) {
    return { ...options, enc: "json", codes, schema };
}
export function textErr(codes, schema, options) {
    return { ...options, err: true, enc: "text", codes, schema };
}
export function text(codes, schema, options) {
    return { ...options, enc: "text", codes, schema };
}
export function bytesErr(codes, schema, options) {
    return { ...options, err: true, enc: "bytes", codes, schema };
}
export function bytes(codes, schema, options) {
    return { ...options, enc: "bytes", codes, schema };
}
export function streamErr(codes, schema, options) {
    return { ...options, err: true, enc: "stream", codes, schema };
}
export function stream(codes, schema, options) {
    return { ...options, enc: "stream", codes, schema };
}
export function sseErr(codes, schema, options) {
    return { ...options, err: true, enc: "sse", codes, schema };
}
export function sse(codes, schema, options) {
    return { ...options, enc: "sse", codes, schema };
}
export function nilErr(codes, schema, options) {
    return { ...options, err: true, enc: "nil", codes, schema };
}
export function nil(codes, schema, options) {
    return { ...options, enc: "nil", codes, schema };
}
export function fail(codes) {
    return { enc: "fail", codes };
}
export function match(...matchers) {
    return async function matchFunc(response, options) {
        let raw;
        let matcher;
        for (const match of matchers) {
            const { codes } = match;
            const ctpattern = "ctype" in match
                ? match.ctype
                : DEFAULT_CONTENT_TYPES[match.enc];
            if (ctpattern && matchResponse(response, codes, ctpattern)) {
                matcher = match;
                break;
            }
            else if (!ctpattern && matchStatusCode(response, codes)) {
                matcher = match;
                break;
            }
        }
        if (!matcher) {
            const responseBody = await response.text();
            return [{
                    ok: false,
                    error: new SDKError("Unexpected API response status or content-type", response, responseBody),
                }, responseBody];
        }
        const encoding = matcher.enc;
        switch (encoding) {
            case "json":
                raw = await response.json();
                break;
            case "bytes":
                raw = new Uint8Array(await response.arrayBuffer());
                break;
            case "stream":
                raw = response.body;
                break;
            case "text":
                raw = await response.text();
                break;
            case "sse":
                raw = response.body;
                break;
            case "nil":
                raw = await discardResponseBody(response);
                break;
            case "fail":
                raw = await response.text();
                break;
            default:
                encoding;
                throw new Error(`Unsupported response type: ${encoding}`);
        }
        if (matcher.enc === "fail") {
            return [{
                    ok: false,
                    error: new SDKError("API error occurred", response, typeof raw === "string" ? raw : ""),
                }, raw];
        }
        const resultKey = matcher.key || options?.resultKey;
        let data;
        if ("err" in matcher) {
            data = {
                ...options?.extraFields,
                ...(matcher.hdrs ? { Headers: unpackHeaders(response.headers) } : null),
                ...(isPlainObject(raw) ? raw : null),
            };
        }
        else if (resultKey) {
            data = {
                ...options?.extraFields,
                ...(matcher.hdrs ? { Headers: unpackHeaders(response.headers) } : null),
                [resultKey]: raw,
            };
        }
        else if (matcher.hdrs) {
            data = {
                ...options?.extraFields,
                ...(matcher.hdrs ? { Headers: unpackHeaders(response.headers) } : null),
                ...(isPlainObject(raw) ? raw : null),
            };
        }
        else {
            data = raw;
        }
        if ("err" in matcher) {
            const result = safeParse(data, (v) => matcher.schema.parse(v), "Response validation failed");
            return [result.ok ? { ok: false, error: result.value } : result, raw];
        }
        else {
            return [
                safeParse(data, (v) => matcher.schema.parse(v), "Response validation failed"),
                raw,
            ];
        }
    };
}
const headerValRE = /, */;
/**
 * Iterates over a Headers object and returns an object with all the header
 * entries. Values are represented as an array to account for repeated headers.
 */
export function unpackHeaders(headers) {
    const out = {};
    for (const [k, v] of headers.entries()) {
        out[k] = v.split(headerValRE);
    }
    return out;
}
/**
 * Discards the response body to free up resources.
 *
 * To learn why this is need, see the undici docs:
 * https://undici.nodejs.org/#/?id=garbage-collection
 */
export async function discardResponseBody(res) {
    const reader = res.body?.getReader();
    if (reader == null) {
        return;
    }
    try {
        let done = false;
        while (!done) {
            const res = await reader.read();
            done = res.done;
        }
    }
    finally {
        reader.releaseLock();
    }
}
//# sourceMappingURL=matchers.js.map