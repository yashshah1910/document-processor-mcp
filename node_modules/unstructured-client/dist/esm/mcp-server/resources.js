/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
import { isAsyncIterable, isBinaryData, valueToBase64 } from "./shared.js";
export async function formatResult(value, uri, init) {
    if (typeof value === "undefined") {
        return { contents: [] };
    }
    let contents = [];
    const mimeType = init.mimeType ?? init.response?.headers.get("content-type")
        ?? "";
    if (mimeType.search(/\bjson\b/g) !== -1) {
        contents = [{ uri: uri.toString(), mimeType, text: JSON.stringify(value) }];
    }
    else if (mimeType.startsWith("text/event-stream")
        && isAsyncIterable(value)) {
        contents = [
            {
                uri: uri.toString(),
                mimeType: "application/json",
                text: await stringifySSEToJSON(value),
            },
        ];
    }
    else if ((mimeType.startsWith("text/") || mimeType.startsWith("application/"))
        && typeof value === "string") {
        contents = [{ uri: uri.toString(), mimeType, text: value }];
    }
    else if (isBinaryData(value)) {
        const blob = await valueToBase64(value);
        contents = blob == null ? [] : [{ uri: uri.toString(), blob, mimeType }];
    }
    else {
        throw new Error(`Unsupported content type: "${mimeType}"`);
    }
    return { contents };
}
async function stringifySSEToJSON(value) {
    const payloads = [];
    for await (const chunk of value) {
        payloads.push(chunk);
    }
    return JSON.stringify(payloads);
}
export function createRegisterResource(logger, server, sdk, allowedScopes) {
    return (resource) => {
        const scopes = resource.scopes ?? [];
        if (!scopes.every((s) => allowedScopes.has(s))) {
            return;
        }
        const metadata = {
            ...resource.metadata,
            description: resource.description,
        };
        server.resource(resource.name, resource.resource, metadata, async (uri, ctx) => resource.read(sdk, uri, ctx));
        logger.debug("Registered resource", { name: resource.name });
    };
}
export function createRegisterResourceTemplate(logger, server, sdk, allowedScopes) {
    return (resource) => {
        const scopes = resource.scopes ?? [];
        if (!scopes.every((s) => allowedScopes.has(s))) {
            return;
        }
        const metadata = {
            ...resource.metadata,
            description: resource.description,
        };
        server.resource(resource.name, resource.resource, metadata, async (uri, vars, ctx) => resource.read(sdk, uri, vars, ctx));
        logger.debug("Registered resource template", { name: resource.name });
    };
}
//# sourceMappingURL=resources.js.map