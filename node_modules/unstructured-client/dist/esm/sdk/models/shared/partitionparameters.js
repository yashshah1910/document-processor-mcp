/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
import * as z from "zod";
import { remap as remap$ } from "../../../lib/primitives.js";
import { safeParse } from "../../../lib/schemas.js";
import { blobLikeSchema } from "../../types/blobs.js";
import { catchUnrecognizedEnum, } from "../../types/enums.js";
/**
 * The format of the response. Supported formats are application/json and text/csv. Default: application/json.
 */
export var OutputFormat;
(function (OutputFormat) {
    OutputFormat["ApplicationJson"] = "application/json";
    OutputFormat["TextCsv"] = "text/csv";
})(OutputFormat || (OutputFormat = {}));
/**
 * The strategy to use for partitioning PDF/image. Options are fast, hi_res, auto. Default: hi_res
 */
export var Strategy;
(function (Strategy) {
    Strategy["Fast"] = "fast";
    Strategy["HiRes"] = "hi_res";
    Strategy["Auto"] = "auto";
    Strategy["OcrOnly"] = "ocr_only";
    Strategy["OdOnly"] = "od_only";
    Strategy["Vlm"] = "vlm";
})(Strategy || (Strategy = {}));
/**
 * The VLM Model to use.
 */
export var VLMModel;
(function (VLMModel) {
    VLMModel["Claude35Sonnet20241022"] = "claude-3-5-sonnet-20241022";
    VLMModel["Gpt4o"] = "gpt-4o";
    VLMModel["Gemini15Pro"] = "gemini-1.5-pro";
    VLMModel["UsAmazonNovaProV10"] = "us.amazon.nova-pro-v1:0";
    VLMModel["UsAmazonNovaLiteV10"] = "us.amazon.nova-lite-v1:0";
    VLMModel["UsAnthropicClaude35Sonnet20241022V20"] = "us.anthropic.claude-3-5-sonnet-20241022-v2:0";
    VLMModel["UsAnthropicClaude3Opus20240229V10"] = "us.anthropic.claude-3-opus-20240229-v1:0";
    VLMModel["UsAnthropicClaude3Haiku20240307V10"] = "us.anthropic.claude-3-haiku-20240307-v1:0";
    VLMModel["UsAnthropicClaude3Sonnet20240229V10"] = "us.anthropic.claude-3-sonnet-20240229-v1:0";
    VLMModel["UsMetaLlama3290bInstructV10"] = "us.meta.llama3-2-90b-instruct-v1:0";
    VLMModel["UsMetaLlama3211bInstructV10"] = "us.meta.llama3-2-11b-instruct-v1:0";
    VLMModel["Gemini20Flash001"] = "gemini-2.0-flash-001";
})(VLMModel || (VLMModel = {}));
/**
 * The VLM Model provider to use.
 */
export var VLMModelProvider;
(function (VLMModelProvider) {
    VLMModelProvider["Openai"] = "openai";
    VLMModelProvider["Anthropic"] = "anthropic";
    VLMModelProvider["Bedrock"] = "bedrock";
    VLMModelProvider["AnthropicBedrock"] = "anthropic_bedrock";
    VLMModelProvider["Vertexai"] = "vertexai";
    VLMModelProvider["Google"] = "google";
    VLMModelProvider["AzureOpenai"] = "azure_openai";
})(VLMModelProvider || (VLMModelProvider = {}));
/** @internal */
export const Files$inboundSchema = z
    .object({
    content: z.union([
        z.instanceof((ReadableStream)),
        z.instanceof(Blob),
        z.instanceof(ArrayBuffer),
        z.instanceof(Uint8Array),
    ]),
    fileName: z.string(),
});
/** @internal */
export const Files$outboundSchema = z.object({
    content: z.union([
        z.instanceof((ReadableStream)),
        z.instanceof(Blob),
        z.instanceof(ArrayBuffer),
        z.instanceof(Uint8Array),
    ]),
    fileName: z.string(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var Files$;
(function (Files$) {
    /** @deprecated use `Files$inboundSchema` instead. */
    Files$.inboundSchema = Files$inboundSchema;
    /** @deprecated use `Files$outboundSchema` instead. */
    Files$.outboundSchema = Files$outboundSchema;
})(Files$ || (Files$ = {}));
export function filesToJSON(files) {
    return JSON.stringify(Files$outboundSchema.parse(files));
}
export function filesFromJSON(jsonString) {
    return safeParse(jsonString, (x) => Files$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Files' from JSON`);
}
/** @internal */
export const OutputFormat$inboundSchema = z
    .union([
    z.nativeEnum(OutputFormat),
    z.string().transform(catchUnrecognizedEnum),
]);
/** @internal */
export const OutputFormat$outboundSchema = z.union([
    z.nativeEnum(OutputFormat),
    z.string().and(z.custom()),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var OutputFormat$;
(function (OutputFormat$) {
    /** @deprecated use `OutputFormat$inboundSchema` instead. */
    OutputFormat$.inboundSchema = OutputFormat$inboundSchema;
    /** @deprecated use `OutputFormat$outboundSchema` instead. */
    OutputFormat$.outboundSchema = OutputFormat$outboundSchema;
})(OutputFormat$ || (OutputFormat$ = {}));
/** @internal */
export const Strategy$inboundSchema = z
    .union([
    z.nativeEnum(Strategy),
    z.string().transform(catchUnrecognizedEnum),
]);
/** @internal */
export const Strategy$outboundSchema = z.union([
    z.nativeEnum(Strategy),
    z.string().and(z.custom()),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var Strategy$;
(function (Strategy$) {
    /** @deprecated use `Strategy$inboundSchema` instead. */
    Strategy$.inboundSchema = Strategy$inboundSchema;
    /** @deprecated use `Strategy$outboundSchema` instead. */
    Strategy$.outboundSchema = Strategy$outboundSchema;
})(Strategy$ || (Strategy$ = {}));
/** @internal */
export const VLMModel$inboundSchema = z
    .union([
    z.nativeEnum(VLMModel),
    z.string().transform(catchUnrecognizedEnum),
]);
/** @internal */
export const VLMModel$outboundSchema = z.union([
    z.nativeEnum(VLMModel),
    z.string().and(z.custom()),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var VLMModel$;
(function (VLMModel$) {
    /** @deprecated use `VLMModel$inboundSchema` instead. */
    VLMModel$.inboundSchema = VLMModel$inboundSchema;
    /** @deprecated use `VLMModel$outboundSchema` instead. */
    VLMModel$.outboundSchema = VLMModel$outboundSchema;
})(VLMModel$ || (VLMModel$ = {}));
/** @internal */
export const VLMModelProvider$inboundSchema = z
    .union([
    z.nativeEnum(VLMModelProvider),
    z.string().transform(catchUnrecognizedEnum),
]);
/** @internal */
export const VLMModelProvider$outboundSchema = z.union([
    z.nativeEnum(VLMModelProvider),
    z.string().and(z.custom()),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var VLMModelProvider$;
(function (VLMModelProvider$) {
    /** @deprecated use `VLMModelProvider$inboundSchema` instead. */
    VLMModelProvider$.inboundSchema = VLMModelProvider$inboundSchema;
    /** @deprecated use `VLMModelProvider$outboundSchema` instead. */
    VLMModelProvider$.outboundSchema = VLMModelProvider$outboundSchema;
})(VLMModelProvider$ || (VLMModelProvider$ = {}));
/** @internal */
export const PartitionParameters$inboundSchema = z.object({
    files: z.lazy(() => Files$inboundSchema),
    chunking_strategy: z.nullable(z.string()).optional(),
    combine_under_n_chars: z.nullable(z.number().int()).optional(),
    content_type: z.nullable(z.string()).optional(),
    coordinates: z.boolean().default(false),
    encoding: z.nullable(z.string()).optional(),
    extract_image_block_types: z.array(z.string()).optional(),
    gz_uncompressed_content_type: z.nullable(z.string()).optional(),
    hi_res_model_name: z.nullable(z.string()).optional(),
    include_orig_elements: z.nullable(z.boolean()).optional(),
    include_page_breaks: z.boolean().default(false),
    include_slide_notes: z.boolean().default(true),
    languages: z.array(z.string()).optional(),
    max_characters: z.nullable(z.number().int()).optional(),
    multipage_sections: z.boolean().default(true),
    new_after_n_chars: z.nullable(z.number().int()).optional(),
    ocr_languages: z.array(z.string()).optional(),
    output_format: OutputFormat$inboundSchema.default(OutputFormat.ApplicationJson),
    overlap: z.number().int().default(0),
    overlap_all: z.boolean().default(false),
    pdf_infer_table_structure: z.boolean().default(true),
    similarity_threshold: z.nullable(z.number()).optional(),
    skip_infer_table_types: z.array(z.string()).optional(),
    split_pdf_allow_failed: z.boolean().default(false),
    split_pdf_concurrency_level: z.number().int().default(5),
    split_pdf_page: z.boolean().default(true),
    split_pdf_page_range: z.array(z.number().int()).optional(),
    starting_page_number: z.nullable(z.number().int()).optional(),
    strategy: Strategy$inboundSchema.default(Strategy.HiRes),
    table_ocr_agent: z.nullable(z.string()).optional(),
    unique_element_ids: z.boolean().default(false),
    vlm_model: VLMModel$inboundSchema.optional(),
    vlm_model_provider: VLMModelProvider$inboundSchema.optional(),
    xml_keep_tags: z.boolean().default(false),
}).transform((v) => {
    return remap$(v, {
        "chunking_strategy": "chunkingStrategy",
        "combine_under_n_chars": "combineUnderNChars",
        "content_type": "contentType",
        "extract_image_block_types": "extractImageBlockTypes",
        "gz_uncompressed_content_type": "gzUncompressedContentType",
        "hi_res_model_name": "hiResModelName",
        "include_orig_elements": "includeOrigElements",
        "include_page_breaks": "includePageBreaks",
        "include_slide_notes": "includeSlideNotes",
        "max_characters": "maxCharacters",
        "multipage_sections": "multipageSections",
        "new_after_n_chars": "newAfterNChars",
        "ocr_languages": "ocrLanguages",
        "output_format": "outputFormat",
        "overlap_all": "overlapAll",
        "pdf_infer_table_structure": "pdfInferTableStructure",
        "similarity_threshold": "similarityThreshold",
        "skip_infer_table_types": "skipInferTableTypes",
        "split_pdf_allow_failed": "splitPdfAllowFailed",
        "split_pdf_concurrency_level": "splitPdfConcurrencyLevel",
        "split_pdf_page": "splitPdfPage",
        "split_pdf_page_range": "splitPdfPageRange",
        "starting_page_number": "startingPageNumber",
        "table_ocr_agent": "tableOcrAgent",
        "unique_element_ids": "uniqueElementIds",
        "vlm_model": "vlmModel",
        "vlm_model_provider": "vlmModelProvider",
        "xml_keep_tags": "xmlKeepTags",
    });
});
/** @internal */
export const PartitionParameters$outboundSchema = z.object({
    files: z.lazy(() => Files$outboundSchema).or(blobLikeSchema),
    chunkingStrategy: z.nullable(z.string()).optional(),
    combineUnderNChars: z.nullable(z.number().int()).optional(),
    contentType: z.nullable(z.string()).optional(),
    coordinates: z.boolean().default(false),
    encoding: z.nullable(z.string()).optional(),
    extractImageBlockTypes: z.array(z.string()).optional(),
    gzUncompressedContentType: z.nullable(z.string()).optional(),
    hiResModelName: z.nullable(z.string()).optional(),
    includeOrigElements: z.nullable(z.boolean()).optional(),
    includePageBreaks: z.boolean().default(false),
    includeSlideNotes: z.boolean().default(true),
    languages: z.array(z.string()).optional(),
    maxCharacters: z.nullable(z.number().int()).optional(),
    multipageSections: z.boolean().default(true),
    newAfterNChars: z.nullable(z.number().int()).optional(),
    ocrLanguages: z.array(z.string()).optional(),
    outputFormat: OutputFormat$outboundSchema.default(OutputFormat.ApplicationJson),
    overlap: z.number().int().default(0),
    overlapAll: z.boolean().default(false),
    pdfInferTableStructure: z.boolean().default(true),
    similarityThreshold: z.nullable(z.number()).optional(),
    skipInferTableTypes: z.array(z.string()).optional(),
    splitPdfAllowFailed: z.boolean().default(false),
    splitPdfConcurrencyLevel: z.number().int().default(5),
    splitPdfPage: z.boolean().default(true),
    splitPdfPageRange: z.array(z.number().int()).optional(),
    startingPageNumber: z.nullable(z.number().int()).optional(),
    strategy: Strategy$outboundSchema.default(Strategy.HiRes),
    tableOcrAgent: z.nullable(z.string()).optional(),
    uniqueElementIds: z.boolean().default(false),
    vlmModel: VLMModel$outboundSchema.optional(),
    vlmModelProvider: VLMModelProvider$outboundSchema.optional(),
    xmlKeepTags: z.boolean().default(false),
}).transform((v) => {
    return remap$(v, {
        chunkingStrategy: "chunking_strategy",
        combineUnderNChars: "combine_under_n_chars",
        contentType: "content_type",
        extractImageBlockTypes: "extract_image_block_types",
        gzUncompressedContentType: "gz_uncompressed_content_type",
        hiResModelName: "hi_res_model_name",
        includeOrigElements: "include_orig_elements",
        includePageBreaks: "include_page_breaks",
        includeSlideNotes: "include_slide_notes",
        maxCharacters: "max_characters",
        multipageSections: "multipage_sections",
        newAfterNChars: "new_after_n_chars",
        ocrLanguages: "ocr_languages",
        outputFormat: "output_format",
        overlapAll: "overlap_all",
        pdfInferTableStructure: "pdf_infer_table_structure",
        similarityThreshold: "similarity_threshold",
        skipInferTableTypes: "skip_infer_table_types",
        splitPdfAllowFailed: "split_pdf_allow_failed",
        splitPdfConcurrencyLevel: "split_pdf_concurrency_level",
        splitPdfPage: "split_pdf_page",
        splitPdfPageRange: "split_pdf_page_range",
        startingPageNumber: "starting_page_number",
        tableOcrAgent: "table_ocr_agent",
        uniqueElementIds: "unique_element_ids",
        vlmModel: "vlm_model",
        vlmModelProvider: "vlm_model_provider",
        xmlKeepTags: "xml_keep_tags",
    });
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var PartitionParameters$;
(function (PartitionParameters$) {
    /** @deprecated use `PartitionParameters$inboundSchema` instead. */
    PartitionParameters$.inboundSchema = PartitionParameters$inboundSchema;
    /** @deprecated use `PartitionParameters$outboundSchema` instead. */
    PartitionParameters$.outboundSchema = PartitionParameters$outboundSchema;
})(PartitionParameters$ || (PartitionParameters$ = {}));
export function partitionParametersToJSON(partitionParameters) {
    return JSON.stringify(PartitionParameters$outboundSchema.parse(partitionParameters));
}
export function partitionParametersFromJSON(jsonString) {
    return safeParse(jsonString, (x) => PartitionParameters$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'PartitionParameters' from JSON`);
}
//# sourceMappingURL=partitionparameters.js.map